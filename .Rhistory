plot(x, dnorm(x, 0, .2), type = "l", lty = 1)
lines(x, dnorm(x,0,2), lty = 3)
lines(x, dnorm(x,0,1), lty = 3)
plot(x, dnorm(x, 0, .2), type = "l", lty = 1)
lines(x, dnorm(x,0,2), lty = 3)
set.seed(1)
n <- 200 # sample size
x1 <- rnorm (n, mean = 0, sd = 1) # first covariate
x2 <- rep (0:1, each = n/2) # second covariate
mu <- exp (2 + 1 * x1 + 0.5 * x2)
alpha <- 0.5
gamma <- 1 / alpha
nu <- rgamma(n, shape = gamma, scale = 1)
y <- rpois(n, lambda = mu * nu / gamma)
pois.glm <- glm(y ~ x1 + x2, family = poisson(link = "log"))
summary(pois.glm)
glm(y ~ x1 + x2, family = poisson(link = "log"))
pois.glm <- glm(y ~ x1 + x2, family = poisson(link = "log"))
summary(pois.glm)
pois.glm <- glm(y ~ x1 + x2, family = poisson(link = "log"))
summary(pois.glm)
plot(pois.glm)
glm.for.quasi <- glm(y ~ x1 + x2, family = quasi(link=log, variance="mu"))
summary(glm.for.quasi)
head(X)
X <- cbind(1, x1, x2)
X
glm.for.quasi$call
glm.for.quasi$coefficients
betahat <- matrix(glm.for.quasi$coefficients, nrow = 3)
betahat
muhat <- exp(X %*% betahat)
muhat
X[i,] %*% t(X[i,])
i=1
X[i,] %*% t(X[i,])
sapply(1:n, function(i) {
X[i,] %*% t(X[i,]) * muhat[i]
})
i=1
(X[i,] %*% t(X[i,])) * muhat[i]
A.a = 0
for (i in 1:n) {
A.a <= A.a + (X[i,] %*% t(X[i,])) * muhat[i]
}
A.a
A.a = 0
for (i in 1:n) {
A.a <- A.a + (X[i,] %*% t(X[i,])) * muhat[i]
}
A.a
A.a <- (1/n) * A.a
A.a
sqrt(A.a)
p <- 3 # the number of predictors
y
phihat <- (1/(n-p)) * sum((y - muhat)^2/muhat)
phihat
Sigma_n <- 0
for (i in 1:n) {
Sigma_n <- Sigma_n + muhat[i]*phihat*(X[i,] %*% t(X[i,]))
}
Sigma_n <- (1/n) * Sigma_n
Sigma_n
alphahat <- (1/(n-p)) * sum(((y-muhat)^2-muhat)/(muhat^2))
alphahat
A.a <- 0
B.a <- 0
for (i in 1:n) {
A.a <- A.a + (X[i,] %*% t(X[i,])) * muhat[i]
B.a <- B.a + (X[i,] %*% t(X[i,])) * (muhat[i]^2 + alphahat * muhat[i]^2)
}
B.a <- (1/n) * B.a
A.a <- (1/n) * A.a
B.a <- (1/n) * B.a
Var.a <- solve(A.a) %*% B %*% solve(A.a)
Var.a <- solve(A.a) %*% B.a %*% solve(A.a)
Var.a
se.a <- sqrt(Var.a[1,1],
Var.a[2,2],
Var.a[3,3])
se.a <- sqrt(c(Var.a[1,1],
Var.a[2,2],
Var.a[3,3]))
se.a
Var.b <- solve(Sigma_n)
Var.b
se.b <- sqrt(c(Var.b[1,1],
Var.b[2,2],
Var.b[3,3]))
quasi.sum <-summary(glm.for.quasi)
quasi.sum$coefficients
quasi.sum$coefficients[,"Std. Error"]
quasi.sum$coefficients[,"Std. Error"]
se.a
se.b
Sigma_n <- 0
for (i in 1:n) {
Sigma_n <- Sigma_n + muhat[i]*phihat*(X[i,] %*% t(X[i,]))
}
Var.b <- solve(Sigma_n)
se.b <- sqrt(c(Var.b[1,1],
Var.b[2,2],
Var.b[3,3]))
quasi.sum$coefficients[,"Std. Error"]
se.a
se.b
Sigma_n <- 0
for (i in 1:n) {
Sigma_n <- Sigma_n + muhat[i]*phihat*(X[i,] %*% t(X[i,]))
}
Var.b <- solve(Sigma_n)
Var.b
se.b <- sqrt(c(Var.b[1,1],
Var.b[2,2],
Var.b[3,3]))
Var.b %*% B.b %*% Var.b
Var.b %*% B.a %*% Var.b
sqrt((Var.b %*% B.a %*% Var.b)[1,1])
Var.b <- solve(Sigma_n) %*% B.a %*% solve(Sigma_n)
se.b <- sqrt(c(Var.b[1,1],
Var.b[2,2],
Var.b[3,3]))
quasi.sum$coefficients[,"Std. Error"]
se.a
se.b
?glm
set.seed(1)
n <- 200 # sample size
x1 <- rnorm (n, mean = 0, sd = 1) # first covariate
x2 <- rep (0:1, each = n/2) # second covariate
mu <- exp (2 + 1 * x1 + 0.5 * x2)
alpha <- 0.5
gamma <- 1 / alpha
nu <- rgamma(n, shape = gamma, scale = 1)
y <- rpois(n, lambda = mu * nu / gamma)
pois.glm <- glm(y ~ x1 + x2, family = poisson(link = "log"))
summary(pois.glm)
plot(pois.glm)
glm.for.quasi <- glm(y ~ x1 + x2, family = quasi(link=log, variance="mu"))
quasi.sum <- summary(glm.for.quasi)
X <- cbind(1, x1, x2)
betahat <- matrix(glm.for.quasi$coefficients, nrow = 3)
muhat <- exp(X %*% betahat)
p <- 3 # the number of predictors
alphahat <- (1/(n-p)) * sum(((y-muhat)^2-muhat)/(muhat^2))
A.a <- 0
B.a <- 0
for (i in 1:n) {
A.a <- A.a + (X[i,] %*% t(X[i,])) * muhat[i]
B.a <- B.a + (X[i,] %*% t(X[i,])) * (muhat[i]^2 + alphahat * muhat[i]^2)
}
A.a <- (1/n) * A.a
B.a <- (1/n) * B.a
Var.a <- solve(A.a) %*% B.a %*% solve(A.a)
se.a <- sqrt(c(Var.a[1,1],
Var.a[2,2],
Var.a[3,3]))
phihat <- (1/(n-p)) * sum((y - muhat)^2/muhat)
phihat
Sigma_n <- 0
for (i in 1:n) {
Sigma_n <- Sigma_n + (1/phihat)*muhat[i]*(X[i,] %*% t(X[i,]))
}
solve(Sigma_n)
sqrt(solve(Sigma_n)[1,1])
quasi.sum$coefficients[,"Std. Error"]
Var.b <- solve(Sigma_n) %*% B.a %*% solve(Sigma_n)
se.b <- sqrt(c(Var.b[1,1],
Var.b[2,2],
Var.b[3,3]))
se.b
Var.b <- solve(Sigma_n)
se.b <- sqrt(c(Var.b[1,1],
Var.b[2,2],
Var.b[3,3]))
quasi.sum$coefficients[,"Std. Error"]
se.a
se.b
library(MASS)
nb.glm <- glm.nb(y ~ x1 + x2)
sum.nb <- summary(nb.glm)
sum.nb
?glm.nb
alpha <- 1/1.660
betahat.nb
betahat.nb <- nb.glm$coefficients
nb.glm$theta
nb.glm$theta
alphahat.nb <- 1/nb.glm$theta
alphahat.nb <- 1/nb.glm$theta
nb.glm$model
summary(nb.glm)
sum.nb
quasi.sum$coefficients[,"Std. Error"]
alphahat.nb
se.a
se.b
library(gee)
gee.pois <- gee(y ~ x1 + x2,
id = 1:n,
family = poisson(link = "log"))
summary(gee.pois)
sum.gee.pois <- summary(gee.pois)
sum.gee.pois$coefficients[, "Robust S.E."]
gee.pois.se <- sum.gee.pois$coefficients[, "Robust S.E."]
gee.pois.se
quasi.sum$coefficients[,"Std. Error"]
summary(pois.glm)$coeficients
sum.pois.glm <- summary(pois.glm)
sum.pois.glm$coefficients
se.a
A.a <- 0
B.a <- 0
for (i in 1:n) {
A.a <- A.a + (X[i,] %*% t(X[i,])) * muhat[i]
B.a <- B.a + (X[i,] %*% t(X[i,])) * (muhat[i] + alphahat * muhat[i]^2)
}
A.a <- (1/n) * A.a
B.a <- (1/n) * B.a
Var.a <- solve(A.a) %*% B.a %*% solve(A.a)
se.a <- sqrt(c(Var.a[1,1],
Var.a[2,2],
Var.a[3,3]))
se.a
A.a <- 0
B.a <- 0
for (i in 1:n) {
A.a <- A.a + (X[i,] %*% t(X[i,])) * muhat[i]
B.a <- B.a + (X[i,] %*% t(X[i,])) * (muhat[i] + alphahat * muhat[i]^2)
}
A.a <- (1/n) * A.a
B.a <- (1/n) * B.a
Var.a <- solve(A.a) %*% B.a %*% solve(A.a)
se.a <- sqrt(c(Var.a[1,1],
Var.a[2,2],
Var.a[3,3]))
se.a
sum.pois.glm$coefficients
sum.pois.glm <- summary(pois.glm)
pois.glm <- glm(y ~ x1 + x2, family = poisson(link = "log"))
sum.pois.glm <- summary(pois.glm)
sum.pois.glm$coefficients
se.pois.glm <- sum.pois.glm$coefficients[, "Std. Error"]
glm.for.quasi <- glm(y ~ x1 + x2, family = quasi(link=log, variance="mu"))
quasi.sum <- summary(glm.for.quasi)
quasi.sum
quasi.sum$coefficients
se.pois.quasi <- quasi.sum$coefficients[, "Std. Error"]
nb.glm <- glm.nb(y ~ x1 + x2)
nb.glm$effects
nb.glm$coefficients
nb.glm$SE.theta
nb.glm$model
nb.glm
summary(nb.glm)
summary(nb.glm)$coefficients
se.nb <- summary(nb.glm)$coefficients[,"Std. Error"]
sum.nb.glm <- summary(nb.glm)
se.nb.glm <- sum.nb.glm$coefficients[,"Std. Error"]
se.nb.glm
sum.pois.glm$coefficients
coef.pois.glm <- sum.pois.glm$coefficients[, "Estimate"]
coef.pois.glm <- quasi.sum$coefficients[, "Estimate"]
sum.nb.glm$coefficients
coef.nb.glm <- sum.nb.glm$coefficients[,"Estimate"]
coef.nb.glm
gee.pois <- gee(y ~ x1 + x2, id = 1:n, family = poisson(link = "log"))
sum.gee.pois <- summary(gee.pois)
sum.gee.pois$coeficients
sum.gee.pois
gee.pois <- gee(y ~ x1 + x2, id = 1:n, family = poisson(link = "log"))
sum.gee.pois <- summary(gee.pois)
sum.gee.pois$coeficients
sum.gee.pois$Coeficients
summary(gee.pois)$Coeficients
sum.gee.pois$coefficients
coef.gee.pois <- sum.gee.pois$coefficients[,"Estimate"]
se.gee.pois <- sum.gee.pois$coefficients[, "Robust S.E."]
Coverage.By.Model <- list(pois.glm = c(),
pois.quasi = c(),
nb.glm = c(),
pois.gee = c())
Coverage.By.Model
Coverage.By.Model <- list(pois.glm = list(intercept = c(),
beta1 = c(),
beta2 = c()),
pois.quasi = list(intercept = c(),
beta1 = c(),
beta2 = c()),
nb.glm = list(intercept = c(),
beta1 = c(),
beta2 = c()),
pois.gee = list(intercept = c(),
beta1 = c(),
beta2 = c()))
Coverage.By.Model
pois.glm <- glm(y ~ x1 + x2, family = poisson(link = "log"))
sum.pois.glm <- summary(pois.glm)
coef.pois.glm <- sum.pois.glm$coefficients[, "Estimate"]
se.pois.glm <- sum.pois.glm$coefficients[, "Std. Error"]
coef.pois.glm
coef.pois.glm + c(-1,1)*1.96*se.pois.glm
se.pois.glm
coef.pois.glm
c(-1,1)*1.96*se.pois.glm
1.96*se.pois.glm
ci.a <- c(coef.pois.glm - 1.96*se.pois.glm,
coef.pois.glm + 1.96*se.pois.glm)
ci.a
param=3
ci.a <- sapply(1:3, function(param) {
coef.pois.glm[param] + c(-1,1)*1.96*se.pois.glm[param]
})
ci.a
ci.a <- lapply(1:3, function(param) {
coef.pois.glm[param] + c(-1,1)*1.96*se.pois.glm[param]
})
ci.a
glm.for.quasi <- glm(y ~ x1 + x2, family = quasi(link=log, variance="mu"))
quasi.sum <- summary(glm.for.quasi)
coef.pois.quais <- quasi.sum$coefficients[, "Estimate"]
se.pois.quasi <- quasi.sum$coefficients[, "Std. Error"]
ci.b <- lapply(1:3, function(param) {
coef.pois.quais[param] + c(-1,1)*1.96*se.pois.quasi[param]
})
ci.b <- lapply(1:3, function(param) {
coef.nb.glm[param] + c(-1,1)*1.96*se.nb.glm[param]
})
ci.e <- lapply(1:3, function(param) {
coef.nb.glm[param] + c(-1,1)*1.96*se.nb.glm[param]
})
ci.f <- lapply(1:3, function(param) {
coef.gee.pois[param] + c(-1,1)*1.96*se.gee.pois[param]
})
ci.f
Coverage.By.Model$pois.glm
Coverage.By.Model$pois.glm$intercept + 1
Coverage.By.Model$pois.glm$intercept <- 0
Coverage.By.Model$pois.glm$intercept
Coverage.By.Model <- list(pois.glm = list(intercept = 0,
beta1 = 0,
beta2 = 0),
pois.quasi = list(intercept = 0,
beta1 = 0,
beta2 = 0),
nb.glm = list(intercept = 0,
beta1 = 0,
beta2 = 0),
pois.gee = list(intercept = 0,
beta1 = 0,
beta2 = 0))
Coverage.By.Model
beta
n <- 200 # sample size
beta <- c(2, 1, 0.5) # the true beta vector
true_beta <- c(2, 1, 0.5) # the true beta vector
true_beta
true_beta_param <- true_beta[param]
ci.a
Coverage.By.Model$pois.glm
ci.a[[param]]
param=1
ci.a[[param]]
contained.a <- (true_beta_param >= ci.a[[param]][1]) & (true_beta_param <= ci.a[[param]][2])
contained.a
true_beta_param
ci.a[[param]]
Coverage.By.Model$nb.glm
contained.a <- (true_beta_param >= ci.a[[param]][1]) & (true_beta_param <= ci.a[[param]][2])
Coverage.By.Model$pois.glm[[param]] = Coverage.By.Model$pois.glm[[param]] + contained.a
contained.b <- (true_beta_param >= ci.b[[param]][1]) & (true_beta_param <= ci.b[[param]][2])
Coverage.By.Model$pois.quasi[[param]] = Coverage.By.Model$pois.quasi[[param]] + contained.b
contained.e <- (true_beta_param >= ci.e[[param]][1]) & (true_beta_param <= ci.e[[param]][2])
Coverage.By.Model$nb.glm[[param]] = Coverage.By.Model$nb.glm[[param]] + contained.e
contained.f <- (true_beta_param >= ci.f[[param]][1]) & (true_beta_param <= ci.f[[param]][2])
Coverage.By.Model$pois.gee[[param]] = Coverage.By.Model$pois.gee[[param]] + contained.f
contained.a
contained.b
contained.e
contained.f
for (param in 1:3) {
true_beta_param <- true_beta[param] # the current true beta
# Checking model (a)
contained.a <- (true_beta_param >= ci.a[[param]][1]) & (true_beta_param <= ci.a[[param]][2])
Coverage.By.Model$pois.glm[[param]] = Coverage.By.Model$pois.glm[[param]] + contained.a
# Checking model (b)
contained.b <- (true_beta_param >= ci.b[[param]][1]) & (true_beta_param <= ci.b[[param]][2])
Coverage.By.Model$pois.quasi[[param]] = Coverage.By.Model$pois.quasi[[param]] + contained.b
# Checking model (e)
contained.e <- (true_beta_param >= ci.e[[param]][1]) & (true_beta_param <= ci.e[[param]][2])
Coverage.By.Model$nb.glm[[param]] = Coverage.By.Model$nb.glm[[param]] + contained.e
# Checking model (f)
contained.f <- (true_beta_param >= ci.f[[param]][1]) & (true_beta_param <= ci.f[[param]][2])
Coverage.By.Model$pois.gee[[param]] = Coverage.By.Model$pois.gee[[param]] + contained.f
}
Coverage.By.Model
param=1
true_beta_param <- true_beta[param] # the current true beta
contained.a <- (true_beta_param >= ci.a[[param]][1]) & (true_beta_param <= ci.a[[param]][2])
Coverage.By.Model$pois.glm[[param]] = Coverage.By.Model$pois.glm[[param]] + contained.a
contained.b <- (true_beta_param >= ci.b[[param]][1]) & (true_beta_param <= ci.b[[param]][2])
Coverage.By.Model$pois.quasi[[param]] = Coverage.By.Model$pois.quasi[[param]] + contained.b
contained.e <- (true_beta_param >= ci.e[[param]][1]) & (true_beta_param <= ci.e[[param]][2])
Coverage.By.Model$nb.glm[[param]] = Coverage.By.Model$nb.glm[[param]] + contained.e
contained.f <- (true_beta_param >= ci.f[[param]][1]) & (true_beta_param <= ci.f[[param]][2])
Coverage.By.Model$pois.gee[[param]] = Coverage.By.Model$pois.gee[[param]] + contained.f
contained.a
contained.b
contained.c
contained.e
contained.f
Coverage.By.Model <- list(pois.glm = list(intercept = 0,
beta1 = 0,
beta2 = 0),
pois.quasi = list(intercept = 0,
beta1 = 0,
beta2 = 0),
nb.glm = list(intercept = 0,
beta1 = 0,
beta2 = 0),
pois.gee = list(intercept = 0,
beta1 = 0,
beta2 = 0))
for (i in 1:100) {
set.seed(i)
# Simulating the dataset
n <- 200 # sample size
true_beta <- c(2, 1, 0.5) # the true beta vector
x1 <- rnorm (n, mean = 0, sd = 1) # first covariate
x2 <- rep (0:1, each = n/2) # second covariate
mu <- exp (2 + 1 * x1 + 0.5 * x2)
alpha <- 0.5
gamma <- 1 / alpha
nu <- rgamma(n, shape = gamma, scale = 1)
y <- rpois(n, lambda = mu * nu / gamma)
# Model (a)
# Ordinary Poisson log-link regression
pois.glm <- glm(y ~ x1 + x2, family = poisson(link = "log"))
sum.pois.glm <- summary(pois.glm)
coef.pois.glm <- sum.pois.glm$coefficients[, "Estimate"]
se.pois.glm <- sum.pois.glm$coefficients[, "Std. Error"]
## Computing the confidence interval
ci.a <- lapply(1:3, function(param) {
coef.pois.glm[param] + c(-1,1)*1.96*se.pois.glm[param]
})
# Model (b)
# Quasi-likelihood model
glm.for.quasi <- glm(y ~ x1 + x2, family = quasi(link=log, variance="mu"))
quasi.sum <- summary(glm.for.quasi)
coef.pois.quais <- quasi.sum$coefficients[, "Estimate"]
se.pois.quasi <- quasi.sum$coefficients[, "Std. Error"]
## Computing the confidence interval
ci.b <- lapply(1:3, function(param) {
coef.pois.quais[param] + c(-1,1)*1.96*se.pois.quasi[param]
})
# Model (e)
# Negative-Binomial regression with log-link
nb.glm <- glm.nb(y ~ x1 + x2)
sum.nb.glm <- summary(nb.glm)
coef.nb.glm <- sum.nb.glm$coefficients[,"Estimate"]
se.nb.glm <- sum.nb.glm$coefficients[,"Std. Error"]
## Computing the confidence interval
ci.e <- lapply(1:3, function(param) {
coef.nb.glm[param] + c(-1,1)*1.96*se.nb.glm[param]
})
# Model (f)
gee.pois <- gee(y ~ x1 + x2, id = 1:n, family = poisson(link = "log"))
sum.gee.pois <- summary(gee.pois)
coef.gee.pois <- sum.gee.pois$coefficients[,"Estimate"]
se.gee.pois <- sum.gee.pois$coefficients[, "Robust S.E."]
## Computing the confidence interval
ci.f <- lapply(1:3, function(param) {
coef.gee.pois[param] + c(-1,1)*1.96*se.gee.pois[param]
})
# Checking if the true values are contained in any of the above intervals
for (param in 1:3) {
true_beta_param <- true_beta[param] # the current true beta
# Checking model (a)
contained.a <- (true_beta_param >= ci.a[[param]][1]) & (true_beta_param <= ci.a[[param]][2])
Coverage.By.Model$pois.glm[[param]] = Coverage.By.Model$pois.glm[[param]] + contained.a
# Checking model (b)
contained.b <- (true_beta_param >= ci.b[[param]][1]) & (true_beta_param <= ci.b[[param]][2])
Coverage.By.Model$pois.quasi[[param]] = Coverage.By.Model$pois.quasi[[param]] + contained.b
# Checking model (e)
contained.e <- (true_beta_param >= ci.e[[param]][1]) & (true_beta_param <= ci.e[[param]][2])
Coverage.By.Model$nb.glm[[param]] = Coverage.By.Model$nb.glm[[param]] + contained.e
# Checking model (f)
contained.f <- (true_beta_param >= ci.f[[param]][1]) & (true_beta_param <= ci.f[[param]][2])
Coverage.By.Model$pois.gee[[param]] = Coverage.By.Model$pois.gee[[param]] + contained.f
}
}
Coverage.By.Model
Coverage.Rate.By.Model <- lapply(Coverage.By.Model, function(mod) {
lapply(mod, function(param) param/100)
})
Coverage.Rate.By.Model
x
x <- seq(-10, 10, by = 0.01)
plot(x, dnorm(x, 0, 0.1), type = l, lty = 2)
plot(x, dnorm(x, 0, 0.1), type = "l", lty = 2)
plot(x, dnorm(x, 0, 0.1), type = "l")
lines(x, dnorm(x, 0, 1), lty = 2)
x <- seq(-5, 5, by = 0.01)
plot(x, dnorm(x, 0, 0.1), type = "l")
lines(x, dnorm(x, 0, 1), lty = 2)
x <- seq(-1, 1, by = 0.01)
plot(x, dnorm(x, 0, 0.1), type = "l")
lines(x, dnorm(x, 0, 1), lty = 2)
plot(x, dnorm(x, 0, 0.1), type = "l", xlab = "Density")
plot(x, dnorm(x, 0, 0.1), type = "l", ylab = "Density")
lines(x, dnorm(x, 0, 1), lty = 2)
